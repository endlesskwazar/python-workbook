# Зміст

${toc}

# ООП. Загальні терміни

## Intro

**Клас** - це фундаментальний будівельний блок в Python. Він лежить в основі не тільки багатьох популярних програм і бібліотек, але і стандартної бібліотеки Python. Розуміння, що таке класи, коли їх використовувати та як вони можуть бути корисними, є важливим навичком і нашою поточною метою. У цьому процесі ми вивчимо, що означає термін «Об’єктно-орієнтоване програмування» та як він пов’язаний разом із класами Python.

## Ключове слово class

Для чого саме використовується ключове слово **class**? Як і його двоюрідний брат, заснований на функціях, він стосується оголошення. У той час як def використовується для визначення функції, class використовується для визначення класу. А що таке клас? Просто логічне групування даних та функцій (останні з них часто називають "методами", коли вони визначені в класі).

Що мається на увазі під логічним групуванням? Ну, клас може містити будь-які дані, які ми хотіли б, і може до нього додавати будь-які функції (методи), які нам подобаються. Замість того, щоб просто з'єднувати випадкові речі разом під назвою "class", ми намагаємось створити класи, де існує логічний зв'язок між речами.

Інколи класи базуються на об'єктах у реальному світі (наприклад, Customer чи Student). В інших випадках класи базуються на таких поняттях у нашій системі, як HTTPRequest або EventLoop.

Незалежно від того, що класи - це техніка моделювання; спосіб мислення про програми. Коли ви думаєте та реалізуєте свою систему таким чином, ви виконуєте об'єктно-орієнтоване програмування. "Класи" та "об'єкти" - це слова, які часто вживаються взаємозамінно, але вони насправді не одне і те саме. Розуміння того, що робить їх різними - це ключ до розуміння того, що вони є, і як вони працюють.

## Оголошення класу

Клас можна розглядати як креслення для створення об’єктів. Коли визначено клас Customer за допомогою ключового слова, фактично самого клыэнта не було створено. Натомість - це свого роду інструкція з побудови об’єктів "Customer". Давайте розглянемо наступний приклад коду:

```py
class Customer(object):
    """A customer of ABC Bank with a checking account. Customers have the
    following properties:

    Attributes:
        name: A string representing the customer's name.
        balance: A float tracking the current balance of the customer's account.
    """

    def __init__(self, name, balance=0.0):
        """Return a Customer object whose name is *name* and starting
        balance is *balance*."""
        self.name = name
        self.balance = balance

    def withdraw(self, amount):
        """Return the balance remaining after withdrawing *amount*
        dollars."""
        if amount > self.balance:
            raise RuntimeError('Amount greater than available balance.')
        self.balance -= amount
        return self.balance

    def deposit(self, amount):
        """Return the balance remaining after depositing *amount*
        dollars."""
        self.balance += amount
        return self.balance
```

Клас Customer(object) не створює нового клієнта. Тобто, лише тому, що ми визначили Customer, це не означає, що ми його створили; ми просто зробили креслення для створення об’єкта «Customer». Для цього ми викликаємо метод __init__ класу з належною кількістю аргументів.

Отже, щоб використати "креслення", яке ми створили, визначивши клас Customer, ми викликаємо ім'я класу майже так, як якщо б це було функцією: jeff = Customer('Jeff Knupp', 1000.0). Цей рядок просто говорить "використовувати креслення Customer, створи мені новий об'єкт, який я буду називати jeff".

Ми, звісно, можемо створити стільки об'єктів Customer, скільки б нам хотілося. Однак існує лише один клас клієнта, незалежно від кількості створених нами примірників класу.

## Атрибути

В прикладі із Customer withdraw і deposit - це атрибути. Атрибути класу бувають двох видів:

- атрибути - дані
- атрибути методи

Атрибути даних зазвичай записуються зверху. Пам'ять для атрибутів виділяється в момент їх першого присвоювання - або зовні, або всередині методу. Методи починаються зі службового слова def.

Доступ до атрибутів виконується за схемою obj.attrname

```py
class Student:

  # атрибут - дані
  name = 'Alex'

  # атрибут - метод
  def printName(self):
    print(self.name)


s = Student()
s.printName()
```

## self

Зазвичай перший аргумент в імені методу - self. Як каже автор мови Гвідо Ван Россум, це не більше ніж традиція: назва self не має абсолютно ніякого спеціального значення.

self корисний для того, щоб звертатися до інших атрибутів класу.

self - це аналог "this" в С++, C#, JAVA

![](../resources/img/5/1.png)

За допомогою self можна додати атрибути-дані. Наприклад, так, але зверніть увагу, що атрибут стане доступним лише після виклику методу. Такий спосіб додавання атрибутів не рекомендований. Атрибути можна додавати в тілі класу і методі __init__ про який ми поговоримо пізніше.

```py
class Student:

  def addName(self):
    self.name = "Alex"


s = Student()
#print(s.name) error
s.addName()
print(s.name)
```

## init

В об'єктно-орієнтованому програмуванні конструктором класу називають метод, який автоматично викликається при створенні об'єктів. Його також можна назвати конструктором об'єктів класу. Ім'я такого методу зазвичай регламентується синтаксисом конкретної мови програмування. Так в Java ім'я конструктора класу збігається з ім'ям самого класу. В Python ж роль конструктора грає метод __init __ ().

В Python наявність пар знаків підкреслення спереду і ззаду в імені методу говорить про те, що він належить до групи методів перевантаження операторів. При цьому методи перевантаження операторів не треба викликати по імені. Викликом для них є сам факт участі об'єкта в певній операції. У разі конструктора класу - це операція створення об'єкта. Так як об'єкт створюється в момент виклику класу по імені, то в цей момент викликається метод __init __ (), якщо він визначений в класі.

Необхідність конструкторів пов'язана з тим, що нерідко об'єкти повинні мати власні властивості відразу.

Розглянемо приклад Student. Для того щоб використовувати цей об'єкт його властивості потрібно ініціалізувати:

```py
class Student:

  def __init__(self, name, age, card):
    self.name = name
    self.age = age
    self.card = card

  def printStudentInfo(self):
    print(self.name + " " + str(self.age) + " " + str(self.card))


# s = Student() missing 3 required positional arguments: 'name', 'age', and 'card'
s = Student("Alex", 23, 18656561523)
s.printStudentInfo()
```

> Зверніть увагу, що ми створили атрибути - даних за допомогою self, але, оскільки, їх створення було в конструкторі - це цілком нормально.


## Перезавантаження операторів

Створимо клас:

```py
class A:

  def __init__(self, a):
    self.a = a
```

І спробуємо додати два його екземпляри:

```py
a = A(12)
b = A(4)
c = a + b
```

![](../resources/img/5/2.png)

Справа в тім, що інтерпретатор python не знає як складати користувацькі класи. Але ми можему йому допомогти, використавши перезавантаження операторів.

Для цього на класі нам потрібно визначити необхідні методи в залежності від операції. Ось таблиця, яка показує відношення методу і оператора:

|Оператор|Метод|
|-|-|
|+|```__add__(self, other)```|
|–|```__sub__(self, other)```|
|*|```__mul__(self, other)```|
|/|```__truediv__(self, other)```|
|//|```__floordiv__(self, other)```|
|%|```__mod__(self, other)```|
|**|```__pow__(self, other)```|

Виправио наш клас A:

```py
class A:

  def __init__(self, a):
    self.a = a

  def __add__(self, other):
    return A(self.a + other.a)


a = A(12)
b = A(4)
c = a + b
print(c.a)
```

Тепер спробуємо порівняти наші об'єкти:

```py
class A:

  def __init__(self, a):
    self.a = a

  def __add__(self, other):
    return A(self.a + other.a)


a = A(12)
b = A(4)

if a > b:
  print("a > b")
```

![](../resources/img/5/3.png)

Справа в тім, що логічні оператори також можна перезавантажувати:

|Оператор|Метод|
|-|-|
|<|```__lt__(self, other)```|
|>|```__gt__(self, other)```|
|<=|```__le__(self, other)```|
|>=|```__ge__(self, other)```|
|==|```__eq__(self, other)```|
|!=|```__ne__(self, other)```|

```py
class A:

  def __init__(self, a):
    self.a = a

  def __add__(self, other):
    return A(self.a + other.a)

  def __gt__(self, other):
    if self.a > other.a:
      return True
    return False


a = A(12)
b = A(4)

if a > b:
  print("a > b")
```

![](../resources/img/5/3.png)

Ось деякі інші оператори, які можна перезавантажувати:

|Оператор|Метод|
|-|-|
|-=|```__isub__(self, other)```|
|+=|```__iadd__(self, other)```|
|*=|```__imul__(self, other)```|
|/=|```__idiv__(self, other)```|
|//=|```__ifloordiv__(self, other)```|
|%=|```__imod__(self, other)```|
|**=|```__ipow__(self, other)```|
|unary -|```__neg__(self, other)```|
|unary +|```__pos__(self, other)```|
|~|```__invert__(self, other)```|


## object

В Python 3 всі об'єкти явно або неявно наслідуються від іншого класу object і наслідують всі його методи:

```py
class A:
  pass


class B(object):
  pass
```

В цих двох випадках класи A і B були в першому прикладі(неявно), а в другому - явно.

Одним з найбільш використовуваних методів класу object є метод ```__str__ ()```. Коли необхідно отримати строкове представлення об'єкту або вивести об'єкт у вигляді рядка, то Python якраз викликає цей метод. І при визначенні класу хорошою практикою вважається перевизначення цього методу.

```py
class Student:

  def __init__(self, name):
    self.name = name


s = Student("Alex")
print(s)
```

У бітьківському класі object вже визначена поведінка для методу ```__str___```. Тому результат ми побічимо, але для людини він буде мало інформативним.

![](../resources/img/5/5.png)

Ми можемо перевизначити цей метод:

```py
class Student:

  def __init__(self, name):
    self.name = name

  def __str__(self):
    return self.name

s = Student("Alex")
print(s)
```

![](../resources/img/5/6.png)

## static

В класах Python можуть існувати статичні поля і статичні методи. Їх можна викликати без створення екземпляра об'єкта і вони загальні для всіх екземплярів, тобто зберігаються в оголошенні класу.

Давайте розглянемо статичні атрибути - дані. Насправді, ми вже з Вами їх створювали. Всі змінні, які оголошені в самому класі є статичними і ми можо отримати до них доступ не створюючи екземпляр об'єкта:

```py
class A:

  a = 3


print(A.a)
```

Але, тут є підводні камні. Справа втім, що при такому оголошенні існує як статична змінна на класі так і динамічна всередині екземпляра:

```py
class A:

  a = 3


print(A.a)
a = A()
print(a.a)
A.a = 5
print(A.a)
print(a.a)
a.a = 7
print(A.a)
print(a.a)
```

![](../resources/img/5/7.png)

# Реалізація принципів ООП в Python

## Інкапсуляція

Читаючи різні статті на тему інкапсуляції, напевно ти стикався з тим, що в програмуванні є два поширених поняття - інкапсуляція і приховування. І під словом «інкапсуляція» автори розуміють то одне, то інше.

Початкове значення слова «інкапсуляція» в програмуванні - об'єднання даних і методів роботи з цими даними в одній упаковці («капсулі»).

В Python в ролі упаковки-капсули виступає клас. Клас містить в собі і дані (поля класу), і методи для роботи з цими даними.

Тепер поговоримо про приховування. 

Як же так виходить, що ми користуємося всякими складними механізмами без розуміння, як вони влаштовані і на чому заснована їхня робота? Все просто: їх творці надали простий і зручний інтерфейс.

На автоматі з газованою водою інтерфейс - це кнопки на панелі. Натиснувши одну кнопку, ти вибираєш обсяг склянки. Натиснувши другу, вибираєш сироп. Третя відповідає за додавання льоду. І це все, що тобі потрібно зробити.

Неважливо, як саме автомат влаштований всередині. Головне - він влаштований так, що для отримання газованої користувачеві потрібно натиснути три кнопки.

Те ж і з автомобілем. Неважливо, що там відбувається у нього всередині. Головне - при натисканні правої педалі автомобіль їде вперед, а при натисненні лівої - гальмує.

Саме в цьому полягає суть приховування. Всі «нутрощі» програми ховаються від користувача. Для нього ця інформація є зайвою, непотрібною. Користувачеві необхідний кінцевий результат, а не внутрішній процес.

Ось приклад інкапсуляції в Java, C++, C#, який досягається модифікаторами доступу private, public, protected:

```java
class Student {
  private String name;

  public Student(String name){
    this.name = name;
  }

  public void printName(){
    System.out.println(this.name);
  }
}

class Main {
  public static void main(String[] args) {
    Student s = new Student("Alex");
    // System.out.println(s.name); error
    s.printName();
  }
}
```

В цьому прикладі отримати доступ до приватної змінної name важко, так-як вона прихована від зовнішнього світу.

В python модифікаторів доступу немає, але використовується інший механізм.

Python 3 надає 3 рівня доступу до даних:

- публічний (public, немає особливого синтаксису);
- захищений (protected, одне нижнє підкреслення на початку назви, _);
- приватний (private, два нижніх підкреслення в початку назви, __).

```py
class Student:

  def __init__(self):
    self.publicName = 'Public Name'
    self._protectedName = 'Protected Name'
    self.__privateName = 'Private Name'

  def printName(self):
    print(self.__privateName)


s = Student()
print(s.publicName)
print(s._protectedName)
#print(s.__privateName) error
s.printName()
```

![](../resources/img/5/8.png)

Поля без підкреслення можуть бути доступні звідусіль. Поля із двома підкресленнями доступні всередині класу. Поля зі одним підкресленням доступні лише для класів в одному модулі.

## Наслідування

Один клас може бути побудований на основі іншого, використовуючи принцип абстракції. Чим вище клас по ієрархії до кореня тим більше він абстрактний. І навпаки, чим дальше - тип більше він конкретна реалізація.

Розглянемо клас:

```py
class Kernel:

  def __init__(self, name, version):
    self.name = name
    self.version = version

  def boot(self):
    print('Botting kernel ', self.name, ' version ', self.version)


k = Kernel('Linux', '5.12')
k.boot()
```

Реалізовуючи новий мехінізм Kernel наприклад PanicMode, ми можемо оператися на вже існуючий клас:

```py
class KernelWithPanicMode(Kernel):

  def __init__(self, name, version, isPanicModeEnabled):
    super(KernelWithPanicMode, self).__init__(name, version)
    self.isPanicModeEnabled = isPanicModeEnabled


k = KernelWithPanicMode('Linux', '5.12', True)
k.boot()
```

Для того, щоб ініціалізувати дочірній клас потрібно ініціалізувати його батькіський клас викликом його конструктора, ось код, який це робить ```super(KernelWithPanicMode, self).__init__(name, version)```

По суті, ми створили KernelWithPanicMode на основі Kernel. В класі KernelWithPanicMode доступні всі атрибути і методи батьківського класу. Також клас KernelWithPanicMode, містить в собі не лише батьківські атрибути, але і додає свій isPanicModeEnabled.

Пошук атрибутів працює по ієрархії: якщо атрибут не знайдеться в поточному класі, пошук триває в базовому класі, і так далі за рекурсією. Дочірні класи можуть перевизначати методи базових класів - всі методи використовуються в цьому стилі віртуальними.

```py
class Kernel:

  def __init__(self, name, version):
    self.name = name
    self.version = version

  def boot(self):
    print('Botting kernel ', self.name, ' version ', self.version)


class KernelWithPanicMode(Kernel):

  def __init__(self, name, version, isPanicModeEnabled):
    super(KernelWithPanicMode, self).__init__(name, version)
    self.isPanicModeEnabled = isPanicModeEnabled

  def boot(self):
    super().boot()
    if self.isPanicModeEnabled:
      print('With panic mode')


k = KernelWithPanicMode('Linux', '5.12', True)
k.boot()
```

![](../resources/img/5/9.png)

## Поліморфізм

# unittest

# Домашнє завдання

# Контрольні запитання