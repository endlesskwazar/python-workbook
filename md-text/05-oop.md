# Зміст

${toc}

# ООП. Загальні терміни

## Intro

**Клас** - це фундаментальний будівельний блок в Python. Він лежить в основі не тільки багатьох популярних програм і бібліотек, але і стандартної бібліотеки Python. Розуміння, що таке класи, коли їх використовувати та як вони можуть бути корисними, є важливим навичком і нашою поточною метою. У цьому процесі ми вивчимо, що означає термін «Об’єктно-орієнтоване програмування» та як він пов’язаний разом із класами Python.

## Ключове слово class

Для чого саме використовується ключове слово **class**? Як і його двоюрідний брат, заснований на функціях, він стосується оголошення. У той час як def використовується для визначення функції, class використовується для визначення класу. А що таке клас? Просто логічне групування даних та функцій (останні з них часто називають "методами", коли вони визначені в класі).

Що мається на увазі під логічним групуванням? Ну, клас може містити будь-які дані, які ми хотіли б, і може до нього додавати будь-які функції (методи), які нам подобаються. Замість того, щоб просто з'єднувати випадкові речі разом під назвою "class", ми намагаємось створити класи, де існує логічний зв'язок між речами.

Інколи класи базуються на об'єктах у реальному світі (наприклад, Customer чи Student). В інших випадках класи базуються на таких поняттях у нашій системі, як HTTPRequest або EventLoop.

Незалежно від того, що класи - це техніка моделювання; спосіб мислення про програми. Коли ви думаєте та реалізуєте свою систему таким чином, ви виконуєте об'єктно-орієнтоване програмування. "Класи" та "об'єкти" - це слова, які часто вживаються взаємозамінно, але вони насправді не одне і те саме. Розуміння того, що робить їх різними - це ключ до розуміння того, що вони є, і як вони працюють.

## Оголошення класу

Клас можна розглядати як креслення для створення об’єктів. Коли визначено клас Customer за допомогою ключового слова, фактично самого клыэнта не було створено. Натомість - це свого роду інструкція з побудови об’єктів "Customer". Давайте розглянемо наступний приклад коду:

```py
class Customer(object):
    """A customer of ABC Bank with a checking account. Customers have the
    following properties:

    Attributes:
        name: A string representing the customer's name.
        balance: A float tracking the current balance of the customer's account.
    """

    def __init__(self, name, balance=0.0):
        """Return a Customer object whose name is *name* and starting
        balance is *balance*."""
        self.name = name
        self.balance = balance

    def withdraw(self, amount):
        """Return the balance remaining after withdrawing *amount*
        dollars."""
        if amount > self.balance:
            raise RuntimeError('Amount greater than available balance.')
        self.balance -= amount
        return self.balance

    def deposit(self, amount):
        """Return the balance remaining after depositing *amount*
        dollars."""
        self.balance += amount
        return self.balance
```

Клас Customer(object) не створює нового клієнта. Тобто, лише тому, що ми визначили Customer, це не означає, що ми його створили; ми просто зробили креслення для створення об’єкта «Customer». Для цього ми викликаємо метод __init__ класу з належною кількістю аргументів.

Отже, щоб використати "креслення", яке ми створили, визначивши клас Customer, ми викликаємо ім'я класу майже так, як якщо б це було функцією: jeff = Customer('Jeff Knupp', 1000.0). Цей рядок просто говорить "використовувати креслення Customer, створи мені новий об'єкт, який я буду називати jeff".

Ми, звісно, можемо створити стільки об'єктів Customer, скільки б нам хотілося. Однак існує лише один клас клієнта, незалежно від кількості створених нами примірників класу.

## self

## init

## object

# Реалізація принципів ООП в Python

## Інкапсуляція

## Поліморфізм

## Наслідування

# Домашнє завдання

# Контрольні запитання