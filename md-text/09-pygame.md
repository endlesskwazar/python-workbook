# Зміст

${toc}

# pygame

**pygame** — набір крос-платформових модулів для Python, призначених для створення відеоігор. Включає в себе бібліотеки комп'ютерної графіки і звуку. pygame був створений, щоб замінити pySDL після його «раптової смерті». pygame базується на **SDL**.

**Simple DirectMedia Layer (SDL)** — кросплатформна мультимедійна бібліотека, вільно поширювана разом із сирцевим кодом. Написана мовою C, яка надає простий інтерфейс до графіки, звуку та пристроїв вводу на різних платформах. Бібліотека SDL надає такі засоби, як швидкий вивід 2D-графіки, обробку вводу, програвання звуку, вивід 3D через OpenGL і безліч інших супутніх операцій у кросплатформовому виді, незалежно від використовуваної системи. Це спрощує створення застосунків і відеоігор, яким необхідно швидко виводити двовимірну графіку, програвати звук, використовувати просунуту обробку вводу користувача тощо.

# Головний цикл

Основний цикл (main loop) гри виконується і оновлює екран через фіксовані інтервали часу. Вони називаються частотою кадрів і визначають плавність переміщення. Зазвичай гри оновлюють екран 30-60 разів в секунду. Якщо частота буде меншою, то здасться, що об'єкти на екрані зависають.

Усередині основного циклу є три основні операції: обробка подій, оновлення стану гри і отрисовка поточного стану на екрані.

```py
import pygame as pg

pg.init()
clock = pg.time.Clock()
running = True
window = pg.display.set_mode((640, 480))
counter = 1

while running:
    clock.tick(60)
    counter += 1
    running = False if counter > 20 else True

pg.quit()
```

# Малювання

Функції модуля pygame.draw малюють геометричні примітиви на поверхні - екземплярі класу Surface. Як перший аргумент вони приймають поверхню. Тому при створенні тієї чи іншої поверхні її треба пов'язати зі змінною, щоб потім було що передати в функції модуля draw.

У більшості випадків фігури малюються всередині головного циклу, так як від кадру до кадру картинка на екрані повинна змінюватися. Тому на кожній ітерації циклу в функції модуля draw передаються дещо змінені аргументи (наприклад, щоразу змінюється координата x).

Однак у нас поки не буде ніякої анімації, і немає сенсу перемальовувати фігури на одному і тому ж місці на кожній ітерації циклу. Тому створювати примітиви будемо в основний гілці програми.

## rectangle

**pygame.Rect** - екземпляри даного класа представляють прямокутні області. Вони не мають графічного представлення у вікні гри. Цінність класу полягає у властивостях і методах, що дозволяють управляти розміщенням поверхонь, виконувати перевірку їх перекриття та ін.

```py
import pygame as pg

pg.init()
window = pg.display.set_mode((640, 480))

r = pg.Rect(0, 0, 30, 30)

while 1:
    for i in pg.event.get():
        if i.type == pg.QUIT:
            exit()
```

Запустивши даний код ми не побачимо прямокутника. Тому що в даному випадку він не має графічного представлення. Але ми можемо заповнити прямокутник, використовуючи клас pygame.Surface.

За допомогою класу **pygame.Surface** можна створювати додаткові поверхні. Після цього малювати їх на основнійй, яка створюється методом pygame.display.set_mode (), або один на одному. Малювання виконується за допомогою методу blit ().

У pygame поверхні створюються не лише викликом функції display.set_mode () або безпосередньо викликом конструктора класу Surface. Також в результаті виконання ряду інших функцій і методів. Це пов'язано з тим, що поверхні грають важливу роль, так як в кінцевому підсумку саме вони відображаються на екрані. Крім того вони дозволяють групувати об'єкти. Їх можна порівняти з шарами в анімації.

При створенні екземпляра Surface безпосередньо від класу необхідно вказати ширину і висоту, подібно до того, як це відбувається при виклику set_mode (). наприклад:

```py
surf = pygame.Surface((150, 150))
```

Метод blit () застосовується до тієї поверхні, на яку "накладається". На якій "малюється", інша. Іншими словами, метод blit () застосовується до батьківської Surface, в той час як дочірня приймає в якості аргументу. Також в метод треба передати координати розміщення верхнього лівого кута дочірньої поверхні в системі координат батьківського. наприклад:

```py
sc.blit(surf, (50, 20))
```

**Приклад Rect + Surface:**

```py
import pygame

pygame.init()

sc = pygame.display.set_mode((300, 300))
#RGB color
sc.fill((200, 255, 200))

surf1 = pygame.Surface((200, 200))
surf1.fill((220, 200, 0))  # желтая
surf2 = pygame.Surface((100, 100))
surf2.fill((255, 255, 255))  # белая

rect = pygame.Rect((70, 20, 0, 0))

surf1.blit(surf2, rect)
sc.blit(surf1, rect)

pygame.display.update()

while 1:
    for i in pygame.event.get():
        if i.type == pygame.QUIT:
            exit()
```

Прямокутники можна малювати безпосерднь ыз створеною поверхнею за допомогою методу rect модуля draw:

```py
import pygame

pygame.init()

sc = pygame.display.set_mode((300, 300))

pygame.draw.rect(sc, (255, 255, 255), (20, 20, 100, 75))
pygame.draw.rect(sc, (64, 128, 255), (150, 20, 100, 75), 8)

pygame.display.update()

while 1:
    for i in pygame.event.get():
        if i.type == pygame.QUIT:
            exit()
```

Сигнатура функції pygame.draw.rect:

```py
rect(surface, color, rect) -> Rect
rect(surface, color, rect, width=0) -> Rect
```

Зазвичай кольори виносять в окремі змінні-константи. Це полегшує читання коду:

```py
import pygame

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (125, 125, 125)
LIGHT_BLUE = (64, 128, 255)
GREEN = (0, 200, 64)
YELLOW = (225, 225, 0)
PINK = (230, 50, 230)

pygame.init()

sc = pygame.display.set_mode((300, 300))

pygame.draw.rect(sc, WHITE, (20, 20, 100, 75))
pygame.draw.rect(sc, LIGHT_BLUE, (150, 20, 100, 75), 8)

pygame.display.update()

while 1:
    for i in pygame.event.get():
        if i.type == pygame.QUIT:
            exit()
```

## line

Щоб намалювати лінію, а точніше - відрізок, треба вказати координати його кінців:

```py
import pygame

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (125, 125, 125)
LIGHT_BLUE = (64, 128, 255)
GREEN = (0, 200, 64)
YELLOW = (225, 225, 0)
PINK = (230, 50, 230)

pygame.init()

sc = pygame.display.set_mode((300, 300))

pygame.draw.line(sc, WHITE, [10, 30], [290, 15], 3)
pygame.draw.line(sc, WHITE, [10, 50], [290, 35])

pygame.display.update()

while 1:
    for i in pygame.event.get():
        if i.type == pygame.QUIT:
            exit()
```

Координати можна передавати як у вигляді списку, так і кортежу.

Функція lines () малюює ламані лінії:

```py
import pygame

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (125, 125, 125)
LIGHT_BLUE = (64, 128, 255)
GREEN = (0, 200, 64)
YELLOW = (225, 225, 0)
PINK = (230, 50, 230)

pygame.init()

sc = pygame.display.set_mode((300, 300))

pygame.draw.lines(sc, WHITE, True, [[10, 10], [140, 70], [280, 20]], 2)

pygame.display.update()

while 1:
    for i in pygame.event.get():
        if i.type == pygame.QUIT:
            exit()
```

Координати визначають місця зламу. Кількість точок може бути довільним. Третій параметр (True або False) вказує замикати чи крайні точки.

## polygon

## circle

## ellipse

## arc

## Проста анімація

# Обробка подій

# Фізика, колізії

# Звук

# Зоображення

# Розробляємо із використанням ООП

# android

# Домашнє завдання

# Контрольні запитання